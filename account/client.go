package account

import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/ranjannkumar/go-grpc-grpahql-microservice/account/pb"

	"google.golang.org/grpc"
)

type Client struct {
	// This field holds the gRPC client connection to the server.
	//  This connection manages the underlying network stream.
	conn *grpc.ClientConn
	//  This field holds an instance of the gRPC service client generated by protoc.
	//  This client provides the methods that directly correspond to the RPCs defined in your AccountService in the .proto file 
	// (e.g., PostAccount, GetAccount, GetAccounts).
	service pb.AccountServiceClient
}
func NewClient(url string) (*Client, error) {
	var conn *grpc.ClientConn
	var err error

	// Define retry parameters
	maxRetries := 5 // Number of retry attempts
	retryInterval := 2 * time.Second // Time between retries
	totalTimeout := 15 * time.Second // Total time to attempt connection

	// Use a context for the overall retry loop
	ctxRetry, cancelRetry := context.WithTimeout(context.Background(), totalTimeout)
	defer cancelRetry()

	for i := 0; i < maxRetries; i++ {
		log.Printf("Attempting to connect to Account service at %s (Attempt %d/%d)...", url, i+1, maxRetries)
		
		// Context for the individual Dial attempt
		ctxDial, cancelDial := context.WithTimeout(context.Background(), retryInterval) // Use retryInterval for individual dial timeout
		defer cancelDial() // Ensure this cancel is called for each loop iteration

		conn, err = grpc.DialContext(ctxDial, url, grpc.WithInsecure(), grpc.WithBlock())
		if err == nil {
			log.Printf("Successfully connected to Account service at %s", url)
			c := pb.NewAccountServiceClient(conn)
			return &Client{conn, c}, nil
		}

		log.Printf("Failed to connect to Account service: %v. Retrying in %v...", err, retryInterval)
		select {
		case <-time.After(retryInterval):
			// Wait for the interval before next retry
		case <-ctxRetry.Done():
			// If overall timeout reached, stop retrying
			return nil, fmt.Errorf("failed to connect to Account service after multiple retries (total timeout reached): %w", ctxRetry.Err())
		}
	}

	return nil, fmt.Errorf("failed to connect to Account service after %d retries: %w", maxRetries, err)
}

func (c *Client)Close(){
	c.conn.Close()
}

func(c *Client)PostAccount(ctx context.Context,name string)(*Account,error){
	r,err:= c.service.PostAccount(
		ctx,
		&pb.PostAccountRequest{Name: name},
	)
	if err!=nil{
		return nil,err
	}
	return &Account{
		ID: r.Account.Id,
		Name: r.Account.Name,
	},nil
}

func(c *Client)GetAccount(ctx context.Context,id string)(*Account,error){
	r,err := c.service.GetAccount(
		ctx,
		&pb.GetAccountRequest{Id: id},
	)
	if err !=nil{
		return nil,err
	}
	return &Account{
		ID: r.Account.Id,
		Name: r.Account.Name,
	},nil
}

func(c *Client)GetAccounts(ctx context.Context,skip uint64,take uint64)([]Account,error){
	r,err := c.service.GetAccounts(
		ctx,
		&pb.GetAccountsRequest{
			Skip: skip,
			Take: take,
		},
	)
	if err !=nil{
		return nil,err
	}
	accounts := []Account{}
	for _,a := range r.Accounts{
		accounts = append(accounts, Account{
			ID: a.Id,
			Name: a.Name,
		})
	}
	return accounts,nil
}

